calc.cpp
------------------------------------------------
#include <iostream>
#include <string>
#include <array>
#include <cmath>
#include <map>
#include "Function.hpp"
#include "calc.tab.hh"

 std::map<std::string, Function> init_func_map()
{
    std::map<std::string, Function> func_map;
    std::array<std::string, 9> func_names = { "sin", "cos", "tan", "asin", "acos", "atan", "log", "ln", "sqrt" };
    std::array<func_t, 9> functions = { sin, cos, tan, asin, acos, atan, log10, log, sqrt };
    for (int i = 0; i < func_names.size(); ++i)
    {
        Function function = { .name = func_names[i], .ptr = functions[i] };
        func_map[function.name] = function;
    }
    return func_map;
}

/* Called by yyparse on error. */
void yyerror(char const *s)
{
    std::cout << "oops" << std::endl;
}

int main (int argc, char const* argv[])
{
    std::map<std::string, Function> func_map = init_func_map();
    yy::parser parsed(func_map);
    return parsed();
}
------------------------------------------------

Function.hpp
------------------------------------------------
#pragma once
#include <functional>
#include <string>

typedef std::function<double(double)> func_t;

struct Function
{
public:
    std::string name;
    func_t ptr;
};
------------------------------------------------

calc.yy
------------------------------------------------
/* Infix notation calculator */

%skeleton "lalr1.cc" // c++
%require "3.8.2"
%header

%define api.token.raw

%define api.token.constructor
%define api.value.type variant
%define parse.assert

%{
  #include <iostream>
  #include <cmath>   // For pow, used in the grammar
  void yyerror(char const *);
%}

%code requires
{
  #include "Function.hpp" // Includes func_map variable, and Function type
  #include <map>
}

// The parsing context
%param { std::map<std::string, Function>& func_map }

// Enable run-time traces (yydebug)
%define parse.trace

%code
{
  #include "yylex.hpp"
}

// Bison declarations
%define api.token.prefix {TOK_}
%token
  ASSIGN "="
  MINUS  "-"
  PLUS   "+"
  STAR   "*"
  SLASH  "/"
  CARAT  "^"
  LPAREN "("
  RPAREN ")"
;
%token NEWLINE "\n"

%precedence "="
%left "-" "+"
%left "*" "/"
%precedence NEG // negation--unary minus
%right "^"      // exponentiation

%token <double>  NUM     // Double precision number
%token <Function> FUN // Function (sin, cos, etc.)
%nterm <double>  exp

// Formatting semantic values
%printer { std::cout << $$.name << "()"; } FUN;
%printer { std::cout << $$; } <double>;

%% /* The grammar follows. */
input:
  %empty
| input line
;

line:
  "\n"
| exp "\n"   { std::cout << $1 << std::endl; }
| error "\n" { yyerrok;                      }
;

exp:
  NUM                { $$ = $1;                         }
| FUN "(" exp ")"    { $$ = $1.ptr($3);                 }
| exp "+" exp        { $$ = $1 + $3;                    }
| exp "-" exp        { $$ = $1 - $3;                    }
| exp "*" exp        { $$ = $1 * $3;                    }
| exp "/" exp        { $$ = $1 / $3;                    }
| "-" exp  %prec NEG { $$ = -$2;                        }
| exp "^" exp        { $$ = pow($1, $3);                }
| "(" exp ")"        { $$ = $2;                         }
;
/* End of grammar. */
%%
void yy::parser::error(const std::string& m)
{
    std::cerr << m << '\n';
}
------------------------------------------------

calc.ll
------------------------------------------------
%{
#include <stdlib.h>
#include "Function.hpp"
#include "calc.tab.hh"
#include "yylex.hpp"
void yyerror(char const *);
%}
%option noyywrap
%%
[ \t]
[0-9]+"."[0-9]+                 { return yy::parser::make_NUM(atof(yytext)); }
[0-9]+                          { return yy::parser::make_NUM(atof(yytext)); }
"+"                             { return yy::parser::make_PLUS(); }
"-"                             { return yy::parser::make_MINUS(); }
"*"                             { return yy::parser::make_STAR(); }
"/"                             { return yy::parser::make_SLASH(); }
"^"                             { return yy::parser::make_CARAT(); }
"("                             { return yy::parser::make_LPAREN(); }
")"                             { return yy::parser::make_RPAREN(); }
sqrt                            { return yy::parser::make_FUN(func_map.at("sqrt")); }
asin                            { return yy::parser::make_FUN(func_map.at("asin")); }
acos                            { return yy::parser::make_FUN(func_map.at("acos")); }
atan                            { return yy::parser::make_FUN(func_map.at("atan")); }
sin                             { return yy::parser::make_FUN(func_map.at("sin")); }
cos                             { return yy::parser::make_FUN(func_map.at("cos")); }
tan                             { return yy::parser::make_FUN(func_map.at("tan")); }
abs                             { return yy::parser::make_FUN(func_map.at("abs")); }
log                             { return yy::parser::make_FUN(func_map.at("log")); }
ln                              { return yy::parser::make_FUN(func_map.at("ln")); }
"\n"                            { return yy::parser::make_NEWLINE(); }
<<EOF>>                         { return yy::parser::make_YYEOF(); }
.                               { yyerror("Undefined symbol"); exit(1); }
%%
------------------------------------------------

cmp.sh
------------------------------------------------
#!/bin/bash

rm calc
bison -d calc.yy
flex calc.ll
g++ calc.tab.cc lex.yy.c calc.cpp -o calc
echo "Done!"
------------------------------------------------
