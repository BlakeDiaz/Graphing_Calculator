calc.h
------------------------------------------------
#ifndef CALC_H
#define CALC_H
// Function type
typedef double (func_t) (double);

// Data type for links in the chain of symbols (symbol record)
typedef struct symrec
{
    char *name;          // name of symbol
    int type;            // type of symbol: either VAR or FUN
    union
    {
        double var;      // value of a var
        func_t *fun;     // value of a FUN
    } value;
    struct symrec *next; // link field
} symrec;

extern symrec *sym_table;

extern symrec *putsym(char const *name, int sym_type);
extern symrec *getsym(char const* name);
#endif
------------------------------------------------



calc.c:
------------------------------------------------
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "calc.tab.h"
#include "calc.h"

typedef struct init
{
    char const *name;
    func_t *fun;
} init;

init const funs[] =
{
    { "sqrt", sqrt  },
    { "asin", asin  },
    { "acos", acos  },
    { "atan", atan  },
    { "sin",  sin   },
    { "cos",  cos   },
    { "tan",  tan   },
    { "log",  log10 },
    { "ln",   log   },
    { 0, 0 },
};

/* The symbol table: a chain of 'struct symrec'. */
symrec *sym_table;

/* Put functions in table. */
static void init_table()
{
    for (int i = 0; funs[i].name; i++)
    {
        symrec *ptr = putsym (funs[i].name, FUN);
        ptr->value.fun = funs[i].fun;
    }
}

/* The mfcalc code assumes that malloc and realloc
   always succeed, and that integer calculations
   never overflow.  Production-quality code should
   not make these assumptions.  */

symrec *putsym(char const *name, int sym_type)
{
    symrec *res = (symrec *) malloc (sizeof (symrec));
    res->name = strdup (name);
    res->type = sym_type;
    res->value.var = 0; /* Set value to 0 even if fun. */
    res->next = sym_table;
    sym_table = res;
    return res;
}

symrec *getsym(char const *name)
{
    for (symrec *p = sym_table; p; p = p->next)
    {
        if (strcmp(p->name, name) == 0)
        {
            return p;
        }
    }
    return NULL;
}

/* Called by yyparse on error. */
void yyerror(char const *s)
{
    fprintf(stderr, "%s\n", s);
}

int main (int argc, char const* argv[])
{
    /* Enable parse traces on option -p. */
    if (argc == 2 && strcmp(argv[1], "-p") == 0)
    {
        yydebug = 1;
    }
    init_table ();
    return yyparse ();
}
------------------------------------------------



calc.y:
------------------------------------------------
/* Infix notation calculator. */

%{
  #include <stdio.h>  /* For printf, etc. */
  #include <math.h>   /* For pow, used in the grammar. */
  int yylex();
  void yyerror(char const *);
%}

%code requires
{
  #include "calc.h" // Contains definition of 'symrec'.
}

/* Bison declarations. */
%define api.value.type union /* Generate YYSTYPE from these types: */
%token <double>  NUM     /* Double precision number. */
%token <symrec*> VAR FUN /* Symbol table pointer: variable/function. */
%nterm <double>  exp

%precedence '='
%left '-' '+'
%left '*' '/'
%precedence NEG /* negation--unary minus */
%right '^'      /* exponentiation */

/* Enable run-time traces (yydebug). */
%define parse.trace

/* Formatting semantic values. */
%printer { fprintf (yyo, "%s", $$->name); } VAR;
%printer { fprintf (yyo, "%s()", $$->name); } FUN;
%printer { fprintf (yyo, "%g", $$); } <double>;
%% /* The grammar follows. */
input:
  %empty
| input line
;

line:
  '\n'
| exp '\n'   { printf("%.10g\n", $1); }
| error '\n' { yyerrok;               }
;

exp:
  NUM                { $$ = $1;                         }
| VAR                { $$ = $1->value.var;              }
| VAR '=' exp        { $$ = $3; $1->value.var = $3;     }
| FUN '(' exp ')'    { $$ = $1->value.fun ($3);         }
| exp '+' exp        { $$ = $1 + $3;                    }
| exp '-' exp        { $$ = $1 - $3;                    }
| exp '*' exp        { $$ = $1 * $3;                    }
| exp '/' exp        { $$ = $1 / $3;                    }
| '-' exp  %prec NEG { $$ = -$2;                        }
| exp '^' exp        { $$ = pow ($1, $3);               }
| '(' exp ')'        { $$ = $2;                         }
;
/* End of grammar. */
%%
------------------------------------------------



calc.l:
------------------------------------------------
%{
#include <stdlib.h>
#include <math.h>
#include "calc.h"
#include "calc.tab.h"
void yyerror(char const *);
%}
%option noyywrap
%%
[ \t]
[0-9]+"."[0-9]+                 { sscanf(yytext, "%lf", &yylval.NUM); return NUM; }
[0-9]+                          { sscanf(yytext, "%lf", &yylval.NUM); return NUM; }
"+"                             { return '+'; }
"-"                             { return '-'; }
"*"                             { return '*'; }
"/"                             { return '/'; }
"^"                             { return '^'; }
"="                             { return '='; }
"("                             { return '('; }
")"                             { return ')'; }
sqrt                            { yylval.FUN = getsym("sqrt"); return FUN; }
asin                            { yylval.FUN = getsym("asin"); return FUN; }
acos                            { yylval.FUN = getsym("acos"); return FUN; }
atan                            { yylval.FUN = getsym("atan"); return FUN; }
sin                             { yylval.FUN = getsym("sin");  return FUN; }
cos                             { yylval.FUN = getsym("cos");  return FUN; }
tan                             { yylval.FUN = getsym("tan");  return FUN; }
abs                             { yylval.FUN = getsym("abs");  return FUN; }
log                             { yylval.FUN = getsym("log");  return FUN; }
ln                              { yylval.FUN = getsym("ln");   return FUN; }
"\n"                            { return '\n'; }
.                               { yyerror("Undefined symbol"); exit(1); }
%%
------------------------------------------------



cmp.sh (compilation script):
------------------------------------------------
#!/bin/bash

rm calc
bison -d calc.y
flex calc.l
gcc calc.tab.c lex.yy.c calc.c -o calc -lm
rm calc.tab.c calc.tab.h lex.yy.c
echo "Done!"
------------------------------------------------
